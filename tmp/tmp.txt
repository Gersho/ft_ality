!!! stuff to remove before pushing (forbidden modules)
-> Format
-> Array ?

!!! reminder those are not allowed !!!
Hashtbl
Map
Printf
Format
Array


################################################################################
################################################################################
################################################################################

https://dune.readthedocs.io/en/stable/quick-start.html

from subject

open forbidden
-> include
-> #require
-> #use

We will be using ocaml 4.14.1

opam switch create 4.14.1
some stuff might be marked deprecated in preparation to OCAML5
-> need to watch out for compilation warnings

You are allowed to use the following modules:
◦ Pervasives
    The initially opened module.

    This module provides the basic operations over the built-in types
    (numbers, booleans, byte sequences, strings, exceptions, references,
    lists, arrays, input-output channels, ...).

    This module is automatically opened at the beginning of each compilation.
    All components of this module can therefore be referred by their short name,
    without prefixing them by Pervasives.

◦ List
    Some functions are flagged as not tail-recursive. 
    The above considerations can usually be ignored
    if your lists are not longer than about 10000 elements.

◦ String
    strings are always immutable

     OCaml strings used to be modifiable in place,
     for instance via the String.set and String.blit functions described below.
     This usage is deprecated and only possible when the compiler
     is put in "unsafe-string" mode by giving the -unsafe-string command-line option
     (which is currently the default for reasons of backward compatibility).
     This is done by making the types string and bytes (see module Bytes) interchangeable
     so that functions expecting byte sequences can also accept strings as arguments and modify them.

!!! All new code should avoid this feature and be compiled with the -safe-string command-line option
    to enforce the separation between the types string and bytes.

◦ Sys
    Every function in this module raises Sys_error
    with an informative message when the underlying system call signal an error.


https://ocamlsdl.sourceforge.net/doc/html/index.html 
◦ Sdl
    This module contains functions for initializing/quitting the library

    val quit : unit -> unit
    quit shuts down all SDL subsystems and frees the resources allocated to them.
    This should always be called before you exit.

◦ Sdlevent
◦ Sdlkey



################################################################################
################################################################################
################################################################################

ocamlsdl has system dep libsdl1.2-dev

https://stackoverflow.com/questions/60938177/linking-to-a-library-in-a-non-standard-path-when-installing-an-opam-package

test opam source ocamlsdl     
Successfully extracted to /nfs/homes/kzennoun/test/ocamlsdl.0.9.1
-> /nfs/homes/kzennoun/local/opam/ocamlsdl.0.9.1

################################################################################
################################################################################
################################################################################

(* allowed modules
Pervasives Sys List String Sdl Sdlevent Sdlkey *)

only list module to take care of data manipulation


types we could use (WIP)
problem: how to get keysym from input string ?

let ality = (config, machine);

let config = keyconfig list; 
type keyconfig =
{
    input_string : string; <- string because it can be "space" (should we support that ?)
    output_string : string;
    input_keysym : Sdlkey.t; <- have to see how events work and
                                how we get keysym/keycode info
}

(copied from turing with suggested modifications)
type transition =
{
    read : char;            <- string not char as actions can be "HP" and such
    to_state : string;      <- int not string because those will be generated and only used internally
    write : char;           <- string, the string to print (ex: "Hadouken")
    action : string         <- not relevant with this type of machine
}

type machine =
{
    name : string;          <- optional, take filename ?
    alphabet : char list;   <- not needed, as we build the machine we know it only uses allowed strings
    blank : char;           <- useless ? no ribbon, nothing happens when no input (blocking wait event ?)
    states : string list;      <- not relevant with this type of machine
    initial : string;       <- useless, should always be 0
    finals : string list;   <- not relevant with this type of machine
    transitions:Assoc (string , transition list);  <- int not string as they are ints now, also we need to use list module
}

so we have

type transition =
{
    read : string
    to_state : int;
    write : string;
}

type state = 
{
  id : int;
  transitions : transition list;
}

(wow it sure got lighter)

current state is int so we should be able to make tail recursive call like
loop machine current_state
current_state is int so always takes same memory and machine too
(wouldn't work with string)

parsing:
split move by -
for each element check if transition/state already exists and add it if not (as "i+1")
"go" to that state for the next element
    ex: (based on SF_Ryu)
    parse
    LP-MP:Light Punch into Medium Punch
    read LP , add LP transition to state 0 creating state 1 ("move" to state 1)
    read MP , add MP transition to state 1 creating state 2
    then parse
    LP-MP-6-2-3-LP:Light Punch into Medium Punch into Shoryuken (Light)
    read LP , state 0 already has that transition in state 1 ("move" to state 1)
    read MP , state 1 already has that transition in state 2 ("move" to state 2)
    read 6  , add 6 transition to state 2 creating state 3 ("move" to state 3)
    read 2  , add 2 transition to state 3 creating state 4 ("move" to state 4)
    etc...

???
can we detect final combo like
LP-MP-6-2-3-LP:Light Punch into Medium Punch into Shoryuken (Light)
by checking if current state has any valid transition before waiting input ?
or should we wait for one additional input that would "break" the combo ?
???

################################################################################
################################################################################
################################################################################
